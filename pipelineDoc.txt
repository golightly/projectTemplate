flappy bird doc

installer checks if you have enough space, and asks for your starting resolution and fullscreen/windows/borderless window.

if you do not have enough space, the installer asks you to free up space and the install button is unresponsive/grayed out.

https://msdn.microsoft.com/en-us/library/windows/desktop/aa364935(v=vs.85).aspx

http://www.tenouk.com/cpluscodesnippet/getdiskfreespacex.html

there is a refresh button which prompts the installer to check again.

once there is enough space the installer sets the data in the config file (is installed, window state, and resolution)



in main game

png = image right after photoshop

run python script to turn image into rgba data

python script runs c++ program

turns rgba data into file of 8bit characters

a program turns all files into one big file

.violent file

runs compression on .violent file

installer decompresses .violent file and asks for resolution to start game at

(.config file saves if installer has been run yet, window state and the resolution to run at)

image = base image from file

apply downscaling, remove base image from memory

tile = image after scaling, contains data and height and width

sprite = contains pointer to tile, and world position x, y, z.

screenElement = pointer to sprite, position on screen.

get whatever rgba values are layered on each pixel of screen space and blend them, including the background into a pixel

pixel: final rgb value

only do this next part until u hit a layer with 255 alpha channel

rgba2 is the bottom layer, rgba1 is on top

test: rgba2: 218, 41, 45, 255   rgba1: 16, 158, 194, 51

outr = 3.2 + 174.4 = 177.6

this agrees with photoshop's result, so this formula works

rOut = (rA * aA / 255) + (rB * aB * (255 - aA) / (255*255))
gOut = (gA * aA / 255) + (gB * aB * (255 - aA) / (255*255))
bOut = (bA * aA / 255) + (bB * aB * (255 - aA) / (255*255))
aOut = aA + (aB * (255 - aA) / 255)

where rA us rgba1 and rB is rgba2

if aOut != 255 use the formula against the background, which is defined elsewhere, but always has 255 alpha.

perform any other operations here (ie. static, noise, colour change etc.)

translate the values to opengl floats and update them into the opengl texture

rOut / 255 = 0.7 rounded

do the rest of the pipeline

detect if anything has changed. ie. any game state updates at all, using a bool.

if so, run the entire operation over again from getting screenElements onward



cmyk test: light green = r9 g168 b94, c99 m47 y53 k25


magenta r113 g49 b82, c53 m90 y47 k25

beige r120 g98 b51, c47 m53 y90 k25


test2: brown r145 g104 b98, c39 m59 y55 k15

brownish green r115 g124 b104 c55 m39 y59 k15

brownish purple r109 g104 b118, c59 m55 y39 k15

RGB -> CMYK
Black = minimum(1 - Red, 1 - Green, 1 - Blue)
Cyan =    (1 - Red - Black)  / (1 - Black)
Magenta = (1 - Green - Black)/ (1 - Black)
Yellow =  (1 - Blue - Black) / (1 - Black)
 
CMYK -> RGB
Red =   1 - minimum(1, Cyan * (1 - Black) + Black)
Green = 1 - minimum(1, Magenta * (1 - Black) + Black)
Blue =  1 - minimum(1, Yellow * (1 - Black) + Black)



these kinds of calculations to be restricted to post-processing, use only rgba/rgb elsewhere

note: ui should be applied after post-processing, even if the ui is semi-transparent.  also ui can be a container for text and images whose positions are stored in relation to the origin (top left corner) of the ui element.

fonts are just an array of images

to be done: test around with opengl stuff, should be able to do with no matrix transformations since the texture will always be the size of the window.

sprites contain a function for rotation

sprites ordinarily use their top left corner as their origin but when they're rotated it toggles a bool that tells the sprite to look at originCentre instead.  the sprite also stores rotationAngle, which is based on the top left corner and the originCentre.  the default position is 0 degrees in this particular system, and the bottom right corner is 180 degrees, and so on, increasing as it goes right (so ie. 90 degrees is the top right corner)

in addition, a rotated sprite stores all of its pixels and its x and y origin in the world as rotatedOrigin


^ add this


so the algorithm is 

void rotate(float adjust) {
	if(!rotation) {
		rotation = true;
		originCentre.x = origin.x + (w / 2); originCentre.y = origin.y + (h / 2);
	}
	angle += adjust;
	if(angle < 0 && angle 
}

